# Test Design: Story 4.1 - Time-Based Viewing Limits

**Date:** 2025-10-31
**Designer:** Quinn (Test Architect)
**Story:** 4.1 - Time-Based Viewing Limits
**Status:** Draft

---

## Executive Summary

### Test Strategy Overview

- **Total test scenarios:** 38
- **Unit tests:** 20 (53%)
- **Integration tests:** 18 (47%)
- **E2E tests:** 0 (0%) - Deferred to later stories
- **Priority distribution:**
  - **P0:** 16 scenarios (42%) - TIER 1 safety + core limit enforcement
  - **P1:** 14 scenarios (37%) - API endpoints + state management
  - **P2:** 8 scenarios (21%) - Admin features + edge cases

### TIER 1 Safety Test Coverage

**Critical child safety rules requiring 100% test coverage:**

1. **Manual/Grace Play Exclusion** (AC4) - 5 scenarios
2. **UTC Time Enforcement** (AC6) - 3 scenarios
3. **SQL Placeholder Usage** (AC4, AC7) - 2 scenarios
4. **Reset Preservation Logic** (AC7) - 3 scenarios

**Total TIER 1 scenarios:** 13 (all P0)

### Coverage Goals

- TIER 1 safety code: **100%** (non-negotiable)
- Business logic: **90%** target
- API endpoints: **85%** target
- Frontend components: **70%** acceptable

---

## Test Scenarios by Acceptance Criteria

### AC1: Watch History Database Tracking

**Requirement:** Watch history entries tracked in database (watched_at, duration_watched_seconds, manual_play, grace_play flags)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-INT-001  | Integration | P1       | Insert watch history entry with all fields | Validates DB schema and constraints |
| 4.1-INT-002  | Integration | P1       | Verify watched_at stored as ISO 8601 UTC | Ensures consistent timestamp format |
| 4.1-INT-003  | Integration | P1       | Check manual_play flag persists correctly | Required for limit calculation exclusion |
| 4.1-INT-004  | Integration | P1       | Check grace_play flag persists correctly | Required for limit calculation exclusion |

**Notes:**
- Foundation from Story 3.1 already implemented
- Integration tests verify DB operations work correctly
- Focus on constraint enforcement and flag persistence

---

### AC2: Daily Limit from Settings

**Requirement:** Daily limit retrieved from settings (default: 30 minutes)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-UNIT-001 | Unit        | P0       | get_setting('daily_limit_minutes') returns configured value | Core logic for limit enforcement |
| 4.1-UNIT-002 | Unit        | P0       | Default to 30 when setting missing (KeyError) | Fallback prevents service disruption |
| 4.1-INT-005  | Integration | P1       | GET /api/limit/status uses settings value | Endpoint integration with settings |

**Notes:**
- P0 for unit tests (accurate limit critical)
- Must handle missing setting gracefully (Story 4.1 Task 1 requirement)
- Integration test verifies end-to-end flow

---

### AC3: Time Tracking Begins on First Video

**Requirement:** Time tracking begins when child first starts a video

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-INT-006  | Integration | P1       | Empty watch history returns 0 minutes watched | Baseline state verification |
| 4.1-INT-007  | Integration | P1       | First video watch increments from 0 | State transition on first use |

**Notes:**
- Already covered by existing get_daily_limit() implementation (Story 3.1)
- Integration tests verify stateless API behavior

---

### AC4: Minutes Calculation Excluding Flags (TIER 1 CRITICAL)

**Requirement:** Minutes watched increments based on duration_watched_seconds (excluding manual_play=true and grace_play=true)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-UNIT-003 | Unit        | P0       | **TIER 1**: Calculate minutes excluding manual_play=true | Child safety: parent reviews don't count |
| 4.1-UNIT-004 | Unit        | P0       | **TIER 1**: Calculate minutes excluding grace_play=true | Child safety: grace videos don't count |
| 4.1-UNIT-005 | Unit        | P0       | **TIER 1**: Mixed entries - exclude both flags | Child safety: complex scenarios |
| 4.1-UNIT-006 | Unit        | P0       | **TIER 1**: Verify SQL query uses placeholders | Security: SQL injection prevention |
| 4.1-INT-008  | Integration | P0       | **TIER 1**: End-to-end limit calculation with DB | Integration: verify query behavior |

**Notes:**
- **CRITICAL**: This is TIER 1 Rule 2 from coding-standards.md
- **100% coverage required** for these tests
- Maps to Story 4.1 Task 8 tests: `test_get_daily_limit_excludes_manual_play()`, `test_get_daily_limit_excludes_grace_play()`
- If this fails, parent "play again" counts toward child's limit - **UNACCEPTABLE**

---

### AC5: Grace Screen When Limit Reached

**Requirement:** When minute limit reached, redirect to grace screen offering one bonus video

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-UNIT-007 | Unit        | P0       | State transitions to 'grace' when minutes_remaining = 0 | Core state machine logic |
| 4.1-INT-009  | Integration | P1       | GET /api/limit/status returns grace state | Endpoint behavior verification |
| 4.1-INT-010  | Integration | P1       | Grace state persists until grace video watched | State persistence logic |

**Notes:**
- State machine transition tested at unit level (fast, isolated)
- Integration tests verify API contract and persistence
- Grace video consumption handled in Story 2.2 (watch history recording)

---

### AC6: Midnight UTC Reset (TIER 1 CRITICAL)

**Requirement:** Limit resets at midnight UTC (UTC timezone enforced, not configurable)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-UNIT-008 | Unit        | P0       | **TIER 1**: get_daily_limit() uses datetime.now(timezone.utc) | Child safety: UTC enforcement |
| 4.1-UNIT-009 | Unit        | P0       | **TIER 1**: Mock non-UTC timezone still uses UTC | Child safety: can't bypass via timezone |
| 4.1-INT-011  | Integration | P0       | **TIER 1**: DB query uses DATE('now') for SQLite UTC | DB-level UTC enforcement |

**Notes:**
- **CRITICAL**: This is TIER 1 Rule 3 from coding-standards.md
- **100% coverage required**
- Maps to Story 4.1 Task 8 test: `test_get_daily_limit_uses_utc_date()`
- If this fails, child could bypass limit by changing device timezone - **UNACCEPTABLE**

---

### AC7: Parent Reset Functionality (TIER 1 CRITICAL)

**Requirement:** Parent can reset limit early via admin interface (deletes today's countable watch_history entries)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-UNIT-010 | Unit        | P0       | **TIER 1**: reset_daily_limit() preserves manual_play=true | Child safety: parent data preserved |
| 4.1-UNIT-011 | Unit        | P0       | **TIER 1**: reset_daily_limit() preserves grace_play=true | Child safety: grace data preserved |
| 4.1-UNIT-012 | Unit        | P0       | **TIER 1**: DELETE query uses SQL placeholders | Security: SQL injection prevention |
| 4.1-INT-012  | Integration | P0       | POST /admin/limit/reset deletes only countable entries | End-to-end preservation verification |
| 4.1-INT-013  | Integration | P0       | Reset requires authentication (require_auth) | Security: admin-only operation |
| 4.1-INT-014  | Integration | P1       | Reset returns updated limit state | API contract verification |
| 4.1-INT-015  | Integration | P2       | Reset handles DB connection failure gracefully | Error handling + rollback |

**Notes:**
- **CRITICAL**: Must preserve manual_play and grace_play entries (TIER 1 Rule 2)
- **100% coverage required** for preservation logic
- Maps to Story 4.1 Task 8 test: `test_limit_reset_only_deletes_countable_entries()`
- Maps to Story 4.1 Task 9 tests: `test_reset_limit_requires_authentication()`, `test_reset_limit_deletes_countable_history()`

---

### AC8: Watch History Persistence

**Requirement:** Watch history persists across browser refreshes (daily limit state recalculated from database on each request)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-INT-016  | Integration | P1       | Call GET /api/limit/status multiple times - consistent | Stateless API verification |
| 4.1-INT-017  | Integration | P1       | Add watch history, status reflects change immediately | DB persistence + recalculation |

**Notes:**
- Tests stateless API design (no in-memory session state)
- Verifies limit state always calculated from DB truth
- Maps to Story 4.1 Task 9 test: `test_limit_status_persists_across_requests()`

---

### AC9: Duration Counting

**Requirement:** Actual duration watched in seconds counts toward limit (tracked via duration_watched_seconds field)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-UNIT-013 | Unit        | P0       | Convert duration_watched_seconds to minutes (÷60) | Accurate time limit calculation |
| 4.1-UNIT-014 | Unit        | P0       | Sum multiple videos' durations correctly | Aggregate calculation logic |
| 4.1-UNIT-015 | Unit        | P1       | Handle partial minutes (floor vs ceiling) | Rounding behavior clarity |

**Notes:**
- Core calculation logic tested at unit level
- P0 for accurate time tracking (critical for limit enforcement)

---

### AC10: Admin Dashboard Display

**Requirement:** Admin dashboard shows current daily limit status (minutes watched, minutes remaining, current state)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-INT-018  | Integration | P2       | GET /admin/dashboard fetches limit status | Admin endpoint integration |
| 4.1-FE-001   | Frontend    | P2       | Display minutes watched/remaining correctly | UI component behavior |
| 4.1-FE-002   | Frontend    | P2       | State badge shows correct visual indicator | Visual state representation |
| 4.1-FE-003   | Frontend    | P2       | Accessibility: ARIA labels present | WCAG compliance (Story 4.1 Task 5) |

**Notes:**
- P2 priority (admin-facing, not child-facing)
- Frontend tests verify component rendering and accessibility
- Not in original Task 10 scope (child interface focus) but valuable for completeness

---

## Cross-Cutting Test Scenarios

### State Machine Transitions

**Requirement:** Daily limit state machine (normal → winddown → grace → locked)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-UNIT-016 | Unit        | P0       | State = 'normal' when minutes_remaining > 10 | State machine: normal state |
| 4.1-UNIT-017 | Unit        | P0       | State = 'winddown' when minutes_remaining ≤ 10 | State machine: winddown state |
| 4.1-UNIT-018 | Unit        | P0       | State = 'grace' when minutes_remaining = 0 and !grace_consumed | State machine: grace state |
| 4.1-UNIT-019 | Unit        | P0       | State = 'locked' when grace_consumed = true | State machine: locked state |

**Notes:**
- Core business logic for child experience
- All P0 (determines video availability and UX)
- Already partially implemented in existing viewing_session.py (from existing tests)

---

### Frontend Polling and Events

**Requirement:** Child interface polls limit status and emits events on state changes (Task 7)

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-FE-004   | Frontend    | P1       | Poll GET /api/limit/status every 30 seconds | Polling mechanism behavior |
| 4.1-FE-005   | Frontend    | P1       | Emit 'limitStateChanged' event on state change | Event-driven architecture |
| 4.1-FE-006   | Frontend    | P1       | Handle poll errors gracefully (don't break UX) | Error handling robustness |
| 4.1-FE-007   | Frontend    | P2       | Pause polling when tab hidden (Page Visibility API) | Performance optimization |
| 4.1-FE-008   | Frontend    | P2       | Increase interval to 60s after 3 consecutive failures | Error recovery strategy |

**Notes:**
- Maps to Story 4.1 Task 10 tests (frontend/src/child/limit-tracker.test.js)
- P1 for core polling behavior, P2 for optimizations
- Critical for real-time limit enforcement in child interface

---

### Edge Cases

**Requirement:** Handle unusual configurations and failure scenarios

**Test Coverage:**

| ID           | Level       | Priority | Test Scenario                          | Justification                          |
| ------------ | ----------- | -------- | -------------------------------------- | -------------------------------------- |
| 4.1-UNIT-020 | Unit        | P2       | Daily limit < 10 minutes (jumps to winddown) | Edge case: small limits |
| 4.1-INT-019  | Integration | P2       | Daily limit = 0 (immediate grace) | Edge case: zero limit |
| 4.1-INT-020  | Integration | P2       | Multiple resets per day (no limit on resets) | Parent flexibility |
| 4.1-INT-021  | Integration | P2       | Child at limit when parent resets (polling detects) | State transition on reset |
| 4.1-INT-022  | Integration | P2       | Midnight UTC transition (automatic reset) | Date boundary handling |
| 4.1-INT-023  | Integration | P2       | Database connection failure during GET /api/limit/status | Error handling (503 response) |

**Notes:**
- Documented in Story 4.1 Dev Notes "Edge Cases to Handle"
- P2 priority (rare scenarios but important for robustness)
- Error handling requirements from Story 4.1 Task 1

---

## Risk Coverage Matrix

### TIER 1 Safety Risks

| Risk ID  | Risk Description                     | Probability | Impact   | Test Coverage                    |
| -------- | ------------------------------------ | ----------- | -------- | -------------------------------- |
| RISK-001 | Parent videos count toward child limit | Medium   | Critical | 4.1-UNIT-003, 004, 005, INT-008 |
| RISK-002 | Timezone bypass allows unlimited viewing | Low      | Critical | 4.1-UNIT-008, 009, INT-011      |
| RISK-003 | SQL injection in limit queries       | Low         | High     | 4.1-UNIT-006, 012                |
| RISK-004 | Reset deletes manual_play history    | Medium      | Critical | 4.1-UNIT-010, 011, INT-012      |

**Mitigation Strategy:**
- All RISK-001 to RISK-004 covered by **P0 TIER 1 tests**
- **100% code coverage** required for these paths
- Tests MUST pass before any deployment

---

### Functional Risks

| Risk ID  | Risk Description                     | Probability | Impact | Test Coverage                    |
| -------- | ------------------------------------ | ----------- | ------ | -------------------------------- |
| RISK-005 | Incorrect limit calculation          | Medium      | High   | 4.1-UNIT-013, 014, 015           |
| RISK-006 | State machine transitions incorrectly | Medium     | High   | 4.1-UNIT-016, 017, 018, 019     |
| RISK-007 | Polling stops on error               | High        | Medium | 4.1-FE-006, 008                  |
| RISK-008 | Admin can't reset when needed        | Low         | Medium | 4.1-INT-013, 014, 015            |

**Mitigation Strategy:**
- RISK-005, 006: **P0** unit tests (core business logic)
- RISK-007: **P1** frontend tests (UX degradation)
- RISK-008: **P1** integration tests (admin functionality)

---

## Test Execution Strategy

### Phase 1: TIER 1 Safety (Fail Fast)

**Execute first - MUST PASS before proceeding:**

1. Run TIER 1 unit tests: `uv run pytest -m tier1 -v tests/backend/services/test_viewing_session_limits.py`
2. Verify 100% coverage on safety-critical code paths
3. If ANY fail: **STOP** - Fix before continuing

**Tests:**
- 4.1-UNIT-003, 004, 005, 006 (manual/grace exclusion, SQL placeholders)
- 4.1-UNIT-008, 009 (UTC enforcement)
- 4.1-UNIT-010, 011, 012 (reset preservation)
- 4.1-INT-008, 011 (DB-level safety)

---

### Phase 2: Core Functionality (P0)

**Execute second - Critical business logic:**

1. Run P0 unit tests: `uv run pytest -m "not tier1" -v tests/backend/services/test_viewing_session_limits.py -k "unit"`
2. Run P0 integration tests: `uv run pytest -v tests/backend/test_routes_limit.py -k "p0"`

**Tests:**
- 4.1-UNIT-001, 002 (settings retrieval + defaults)
- 4.1-UNIT-007 (grace state transition)
- 4.1-UNIT-013, 014 (duration calculation)
- 4.1-UNIT-016, 017, 018, 019 (state machine)
- 4.1-INT-012, 013 (reset + auth)

---

### Phase 3: API Contracts (P1)

**Execute third - Endpoint behavior:**

1. Run integration tests: `uv run pytest -v tests/backend/test_routes_limit.py`
2. Run frontend tests: `npm test`

**Tests:**
- All 4.1-INT-* tests (AC1, AC2, AC3, AC5, AC7, AC8)
- All 4.1-FE-* tests (polling, events, error handling)

---

### Phase 4: Edge Cases and Admin (P2)

**Execute last - Time permitting:**

1. Run P2 integration tests: `uv run pytest -v tests/backend/test_routes_limit.py -k "p2"`
2. Run P2 frontend tests: `npm test -- --grep "P2"`

**Tests:**
- 4.1-UNIT-020 (small limit edge case)
- 4.1-INT-019 to 023 (edge cases)
- 4.1-INT-018, FE-001, 002, 003 (admin dashboard)

---

### Continuous Integration

**Pre-commit checks:**
```bash
# TIER 1 safety tests (required)
uv run pytest -m tier1 -v

# All tests (recommended)
uv run pytest tests/backend/ -v --cov=backend --cov-report=term-missing
npm test

# Linting (required)
uv run black . && uv run ruff check . && npm run lint
```

---

## Alignment with Story Tasks

### Task 8: TIER 1 Safety Tests

**File:** `tests/backend/services/test_viewing_session_limits.py`

**Story-specified tests:**
- ✓ `test_get_daily_limit_excludes_manual_play()` → **4.1-UNIT-003**
- ✓ `test_get_daily_limit_excludes_grace_play()` → **4.1-UNIT-004**
- ✓ `test_get_daily_limit_uses_utc_date()` → **4.1-UNIT-008**
- ✓ `test_limit_reset_only_deletes_countable_entries()` → **4.1-UNIT-010, 011**

**Additional TIER 1 tests recommended:**
- **4.1-UNIT-005**: Mixed manual and grace entries (complex scenario)
- **4.1-UNIT-006, 012**: SQL placeholder verification
- **4.1-UNIT-009**: Mock timezone test (defensive)
- **4.1-INT-008, 011**: DB-level safety verification

**Total TIER 1 tests:** 13 (4 from Task 8 + 9 additional)

---

### Task 9: Integration Tests

**File:** `tests/backend/test_routes_limit.py`

**Story-specified tests:**
- ✓ `test_get_limit_status_returns_current_state()` → **4.1-INT-009**
- ✓ `test_reset_limit_requires_authentication()` → **4.1-INT-013**
- ✓ `test_reset_limit_deletes_countable_history()` → **4.1-INT-012**
- ✓ `test_limit_status_persists_across_requests()` → **4.1-INT-016**

**Additional integration tests recommended:**
- **4.1-INT-001 to 007**: AC1, AC2, AC3 coverage
- **4.1-INT-010, 011**: Grace state and UTC DB enforcement
- **4.1-INT-014, 015**: Reset response + error handling
- **4.1-INT-017 to 023**: Persistence, admin, edge cases

**Total integration tests:** 18 (4 from Task 9 + 14 additional)

---

### Task 10: Frontend Tests

**File:** `frontend/src/child/limit-tracker.test.js`

**Story-specified test areas:**
- ✓ Poll interval executes every 30 seconds → **4.1-FE-004**
- ✓ State changes emit correct events → **4.1-FE-005**
- ✓ Errors don't break polling loop → **4.1-FE-006**

**Additional frontend tests recommended:**
- **4.1-FE-007**: Page Visibility API optimization
- **4.1-FE-008**: Error recovery with increased interval
- **4.1-FE-001, 002, 003**: Admin dashboard display (if implemented)

**Total frontend tests:** 8 (3 from Task 10 + 5 additional)

---

## Coverage Gaps and Recommendations

### Gaps Identified

**None critical.** All acceptance criteria have test coverage.

---

### Recommendations

#### Immediate (Must Do)

1. **Implement all TIER 1 tests (13 scenarios)** - Non-negotiable for child safety
2. **Achieve 100% coverage on TIER 1 code paths** - Use `pytest --cov` to verify
3. **Implement all P0 unit tests (state machine + calculations)** - Core business logic

#### High Priority (Should Do)

4. **Implement all P1 integration tests (API contracts)** - Ensures endpoint reliability
5. **Implement all P1 frontend tests (polling + events)** - Real-time limit enforcement
6. **Add SQL injection prevention tests** - Security best practice

#### Nice to Have (Could Do)

7. **Implement P2 edge case tests** - Improves robustness
8. **Add performance benchmarks** - Track query execution time for limit calculations
9. **Add admin dashboard frontend tests** - If dashboard is implemented in this story

---

### Test Data Strategy

**Fixtures needed** (add to `tests/backend/conftest.py`):

```python
@pytest.fixture
def mock_watch_history_mixed():
    """Watch history with countable, manual_play, and grace_play entries."""
    return [
        # Countable (15 minutes)
        {"videoId": "v1", "durationWatchedSeconds": 900, "manualPlay": False, "gracePlay": False},

        # Manual play (NOT countable, 10 minutes)
        {"videoId": "v2", "durationWatchedSeconds": 600, "manualPlay": True, "gracePlay": False},

        # Grace play (NOT countable, 5 minutes)
        {"videoId": "v3", "durationWatchedSeconds": 300, "manualPlay": False, "gracePlay": True},
    ]
    # Expected: 15 minutes counted (v1 only)

@pytest.fixture
def mock_settings_30min():
    """Settings with 30 minute daily limit."""
    return {"daily_limit_minutes": "30"}

@pytest.fixture
def mock_utc_date():
    """Current UTC date for testing."""
    return datetime.now(timezone.utc).date().isoformat()
```

---

## Quality Checklist

**Before finalizing implementation:**

- ✓ Every AC has test coverage
- ✓ TIER 1 tests identified (13 scenarios)
- ✓ Test levels appropriate (unit for logic, integration for endpoints)
- ✓ No duplicate coverage across levels (unit tests mock, integration tests use DB)
- ✓ Priorities align with business risk (P0 for safety + core, P1 for features, P2 for edge cases)
- ✓ Test IDs follow naming convention (4.1-UNIT-001, 4.1-INT-001, 4.1-FE-001)
- ✓ Scenarios are atomic and independent (can run in any order)
- ✓ Mapped to existing Story 4.1 Tasks 8-10

---

## Next Steps

### For Development Team

1. **Implement TIER 1 tests first** (Task 8 + additions) - These are critical path
2. **Run `pytest -m tier1` after each TIER 1 test** - Ensure they pass individually
3. **Implement P0 unit tests** - Core business logic (state machine, calculations)
4. **Implement integration tests** (Task 9 + additions) - API contracts
5. **Implement frontend tests** (Task 10 + additions) - Child interface polling
6. **Run full test suite before PR:** `uv run pytest tests/backend/ -v --cov=backend && npm test`

### For QA Review

1. **Verify TIER 1 coverage reaches 100%** - Use coverage report
2. **Execute test execution strategy** - Follow phase 1-4 order
3. **Document any new risks discovered during testing** - Update risk matrix
4. **Create quality gate decision** - Use `*gate 4.1` command after tests implemented

---

## Appendix: Test Framework References

### Test Level Decision Criteria

**Source:** `.bmad-core/data/test-levels-framework.md`

- **Unit:** Pure functions, business logic, algorithms, state machines
- **Integration:** Component interactions, DB operations, API contracts, service communication
- **E2E:** Critical user journeys, cross-system workflows, compliance scenarios

### Priority Classification

**Source:** `.bmad-core/data/test-priorities-matrix.md`

- **P0:** Revenue-critical, security, data integrity, compliance, TIER 1 safety
- **P1:** Core user journeys, frequently used, complex logic, integration points
- **P2:** Secondary features, admin functionality, reporting
- **P3:** Rarely used, nice-to-have, cosmetic (none in this story)

### Test Naming Convention

**Format:** `{EPIC}.{STORY}-{LEVEL}-{SEQ}`

**Examples:**
- `4.1-UNIT-001` - First unit test for Story 4.1
- `4.1-INT-012` - Twelfth integration test for Story 4.1
- `4.1-FE-004` - Fourth frontend test for Story 4.1

---

**END OF TEST DESIGN DOCUMENT**
